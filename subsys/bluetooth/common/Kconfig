# Bluetooth common configuration options

# Copyright (c) 2017 Nordic Semiconductor ASA
# Copyright (c) 2016 Intel Corporation
# SPDX-License-Identifier: Apache-2.0

config BT_BUF_ACL_TX_SIZE
	int "Maximum support ACL size for outgoing data"
	range 27 251
	default 27
	help
	  Size of the Tx buffers and the value returned in HCI LE Read Buffer
	  Size command response. If this size if greater than effective PDU size
	  then controller will perform fragmentation before transmitting on the
	  the packet on air.
	  Maximum is set to 251 due to implementation limitations (use of
	  uint8_t for length field in PDU buffer structure

config BT_BUF_ACL_TX_COUNT
	int "Number of outgoing ACL data buffers"
	default 7 if BT_HCI_RAW
	default 3
	range 1 19
	help
	  Set the number of Tx PDUs to be queued for transmission in the
	  controller. In a 7.5ms connection interval and 2M PHY, maximum 19
	  packets can be enqueued, with 18 packets with L2CAP payload size of 1
	  byte can be acknowledged.

config BT_BUF_ACL_RX_SIZE
	int "Maximum supported ACL size for incoming data"
	default 200 if BT_BREDR # ???
	# Mesh Proxy Recommended: 64 Pkey + 2 Bytes Mesh header.
	# Overhead: Write command Header (3) in an L2CAP B-frame (4).
	default 73 if BT_MESH_PROXY
	default 70 if BT_EATT
	default 69 if BT_SMP
	default 27
	range 70 1300 if BT_EATT
	range 69 1300 if BT_SMP
	range 27 1300
	help
	  Size of the Rx buffers and the value given in the HCI Host Buffer Size
	  command when Controller to Host ACL flow control has been enabled.
	  Note that buffer sizes are always rounded up to the nearest multiple
	  of 4, so if this Kconfig value is something else then there will be
	  some wasted space.

	  With Enhaced ATT enabled the minimum of 70 is needed to support the
	  minimum ATT_MTU of 64 octets in an L2CAP K-frame.
	  With SMP LE Secure Connections enabled the minimum of 69 is needed to
	  support the minimum SMP MTU of 65 octets (public key + opcode) in an
	  L2CAP B-frame.

	  Overhead of an L2CAP B-frame is a 4 bytes header.
	  Overhead of an L2CAP K-frame is a 2 byte SDU length field plus the
	  4 bytes header of an L2CAP B-frame.

config BT_BUF_ACL_RX_COUNT
	int "Number of incoming ACL data buffers"
	default NET_BUF_RX_COUNT if NET_L2_BT
	default 3 if BT_RECV_IS_RX_THREAD
	default 6
	range 1 64
	help
	  Number of buffers available for incoming ACL data.

config BT_BUF_EVT_RX_SIZE
	int "Maximum supported HCI Event buffer length"
	default 262 if BT_BREDR # ???
	default 255 if (BT_EXT_ADV && !(BT_DISCARDABLE_BUF_COUNT > 0))
	# default 255 if BT_EXT_ADV
	default 72
	range 69 2000
	help
	  Maximum data size for each HCI RX buffer. This size includes
	  everything starting with the ACL or HCI event headers. Note that
	  buffer sizes are always rounded up to the nearest multiple of 4,
	  so if this Kconfig value is something else then there will be some
	  wasted space. The minimum of 73 has been taken for LE SC which has
	  an L2CAP MTU of 65 bytes. On top of this there's the L2CAP header
	  (4 bytes) and the ACL header (also 4 bytes) which yields 73 bytes.

config BT_BUF_EVT_RX_COUNT
	int "Number of HCI Event buffers"
	default 3 if BT_RECV_IS_RX_THREAD
	default 20 if (BT_MESH && !(BT_DISCARDABLE_BUF_COUNT > 0))
	default 10
	range 2 255
	help
	  Number of buffers available for incoming ACL packets or HCI events
	  from the controller.

	  When HCI ACL flow control is enabled this is only used for HCI events
	  from the controller.

config BT_BUF_CMD_TX_SIZE
	int "Maximum support HCI Command buffer length"
	default 262 if BT_BREDR # ???
	default 255 if BT_EXT_ADV
	range 64 255
	help
	  Maximum data size for each HCI Command buffer. This size excludes the
	  HCI Command header.

config BT_BUF_CMD_TX_COUNT
	int "Number of HCI command buffers"
	default 2
	range 2 64
	help
	  Number of buffers available for HCI commands.

config BT_HAS_HCI_VS
	bool
	help
	  This option is set by the Bluetooth controller to indicate support
	  for the Zephyr HCI Vendor-Specific Commands and Event.

config BT_HCI_VS
	bool "Zephyr HCI Vendor-Specific Commands"
	depends on BT_HAS_HCI_VS || !BT_CTLR
	default y if BT_HAS_HCI_VS
	help
	  Enable support for the Zephyr HCI Vendor-Specific Commands in the
	  Host and/or Controller. This enables Set Version Information,
	  Supported Commands, Supported Features vendor commands.

config BT_HCI_VS_EXT
	bool "Zephyr HCI Vendor-Specific Extensions"
	depends on BT_HCI_VS
	default y
	help
	  Enable support for the Zephyr HCI Vendor-Specific Extensions in the
	  Host and/or Controller. This enables  Write BD_ADDR, Read Build Info,
	  Read Static Addresses and Read Key Hierarchy Roots vendor commands.

config BT_HCI_VS_EXT_DETECT
	bool "Use heuristics to guess HCI vendor extensions support in advance"
	depends on BT_HCI_VS_EXT && !BT_CTLR
	default y if BOARD_QEMU_X86 || BOARD_QEMU_CORTEX_M3 || BOARD_NATIVE_POSIX
	help
	  Use some heuristics to try to guess in advance whether the controller
	  supports the HCI vendor extensions in advance, in order to prevent
	  sending vendor commands to controller which may interpret them in
	  completely different ways.

config BT_HCI_MESH_EXT
	bool "Mesh HCI Command support"
	depends on BT_BROADCASTER && BT_OBSERVER && !BT_LL_SW_SPLIT
	help
	  Enable support for the Bluetooth Mesh HCI Commands.

config BT_WAIT_NOP
	bool "Wait for \"NOP\" Command Complete event during init"
	help
	  Emit a Command Complete event from the Controller (and wait for it
	  from the Host) for the NOP opcode to indicate that the Controller is
	  ready to receive commands.

config BT_RPA
	bool
	select TINYCRYPT
	select TINYCRYPT_AES

config BT_ASSERT
	bool "Custom Bluetooth assert implementation"
	default y
	help
	  Use a custom Bluetooth assert implementation instead of the
	  kernel-wide __ASSERT() when CONFIG_ASSERT is disabled.

if BT_ASSERT

config BT_ASSERT_VERBOSE
	bool "Print out an assert string when using BT_ASSERT"
	default y
	help
	  When CONFIG_BT_ASSERT is enabled, this option turns on printing the
	  cause of the assert to the console using printk().

config BT_ASSERT_PANIC
	bool "Use k_panic() instead of k_oops()"
	help
	  When CONFIG_BT_ASSERT is enabled, this option makes the code call
	  k_panic() instead of k_oops() when an assertion is triggered.

endif # BT_ASSERT

config BT_DEBUG
	# Hidden option to make the conditions more intuitive
	bool

choice
	prompt "Bluetooth debug type"
	default BT_DEBUG_NONE

config BT_DEBUG_NONE
	bool "No debug log"
	help
	  Select this to disable all Bluetooth debug logs.

config BT_DEBUG_LOG
	bool "Normal printf-style to console"
	select BT_DEBUG
	select LOG
	help
	  This option enables Bluetooth debug going to standard
	  serial console.

config BT_DEBUG_MONITOR
	bool "Monitor protocol over UART"
	select BT_DEBUG
	select LOG
	select CONSOLE_HAS_DRIVER
	help
	  Use a custom logging protocol over the console UART
	  instead of plain-text output. Requires a special application
	  on the host side that can decode this protocol. Currently
	  the 'btmon' tool from BlueZ is capable of doing this.

	  If the target board has two or more external UARTs it is
	  possible to keep using UART_CONSOLE together with this option,
	  however if there is only a single external UART then
	  UART_CONSOLE needs to be disabled (in which case printk/printf
	  will get encoded into the monitor protocol).

endchoice

if BT_DEBUG

# Workaround for not being able to have commas in macro arguments
DT_CHOSEN_Z_BT_MON_UART := zephyr,bt-mon-uart

config BT_MONITOR_ON_DEV_NAME
	string "Device Name of Bluetooth monitor logging UART"
	depends on BT_DEBUG_MONITOR
	default "$(dt_chosen_label,$(DT_CHOSEN_Z_BT_MON_UART))" if HAS_DTS
	default "UART_0"
	help
	  This option specifies the name of UART device to be used
	  for the Bluetooth monitor logging.

config BT_DEBUG_HCI_DRIVER
	bool "Bluetooth HCI driver debug"
	help
	  This option enables debug support for the active
	  Bluetooth HCI driver, including the Controller-side HCI layer
	  when included in the build.

config BT_DEBUG_RPA
	bool "Bluetooth Resolvable Private Address (RPA) debug"
	depends on BT_RPA
	help
	  This option enables debug support for the Bluetooth
	  Resolvable Private Address (RPA) generation and resolution.

endif # BT_DEBUG
